" Skip plugins instalation on vim-tiny and vim-small
if 0 | finish | endif

if has('vim_starting')
  set nocompatible
endif

call plug#begin('~/.vim/plugged')

" Plug 'vim-syntastic/syntastic'
" Plug 'altercation/vim-colors-solarized'
" Plug 'ervandew/supertab'

" Tmux
Plug 'christoomey/vim-tmux-navigator'
Plug 'benmills/vimux'

" General
" Plug 'tpope/vim-vinegar'
Plug 'gcmt/taboo.vim'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-abolish'

" Devel
Plug 'vim-scripts/SyntaxComplete'
Plug 'vim-scripts/XSLT-syntax'
Plug 'plasticboy/vim-markdown'
Plug 'tpope/vim-git'
Plug 'docker/docker' , {'rtp': '/contrib/syntax/vim/'}
Plug 'dag/vim-fish'
Plug 'elzr/vim-json'
Plug 'stephpy/vim-yaml'
Plug 'lfilho/cosco.vim'
Plug 'vim-scripts/Rainbow-Parenthsis-Bundle'
Plug 'vim-scripts/taglist.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'tpope/vim-commentary'
" Plug 'prettier/vim-prettier', { 'do': 'yarn install' }
" Plug 'jonas/tig' " git tool, week support, a lot of issues

" Web
Plug 'othree/html5.vim'
Plug 'JulesWang/css.vim'
Plug 'ap/vim-css-color'
Plug 'digitaltoad/vim-pug'
Plug 'groenewege/vim-less'
Plug 'wavded/vim-stylus'
Plug 'benjifisher/matchit.zip'

" Python
Plug 'mitsuhiko/vim-python-combined'
Plug 'aliev/vim-compiler-python'

" Ruby
Plug 'vim-ruby/vim-ruby'
Plug 'tpope/vim-rails'
Plug 'sheerun/vim-yardoc'

" PHP
Plug 'StanAngeloff/php.vim'
Plug 'mxw/vim-xhp'

" Javascript
Plug 'othree/javascript-libraries-syntax.vim'
Plug 'glanotte/vim-jasmine'
Plug 'pangloss/vim-javascript'
Plug 'mxw/vim-jsx'
Plug 'leafgarland/typescript-vim'
Plug 'othree/yajs.vim'
Plug 'jason0x43/vim-js-indent'
Plug 'maksimr/vim-jsbeautify'
" Plug 'moll/vim-node'
" Plug 'wookiehangover/jshint.vim'
Plug 'juanpabloaj/vim-istanbul'
" Lint engine
Plug 'w0rp/ale'

" Plug 'tpope/vim-speeddating'
Plug 'henrik/vim-indexed-search'
" Plug 'janko-m/vim-test'
" Plug 'skywind3000/asyncrun.vim'
Plug 'victormours/better-writing.vim'
" Plug 'vim-scripts/CursorLineCurrentWindow'
" Plug 'yegappan/mru'
Plug 'tpope/vim-repeat'
Plug 'mattn/emmet-vim'
" Plug 'csscomb/vim-csscomb'
Plug 'othree/xml.vim'
" Plug 'alvan/vim-closetag'
" Plug '1995eaton/vim-better-javascript-completion'
Plug 'AndrewRadev/splitjoin.vim'
" Plug 'kana/vim-textobj-user'
" Plug 'vim-scripts/ConflictMotions'
" Plug 'skammer/vim-css-color'
Plug 'godlygeek/tabular'
" Plug 'flowtype/vim-flow'
" Plug 'vim-scripts/Conque-Shell'
" Plug 'Chiel92/vim-autoformat'
" Plug 'scrooloose/syntastic'
" Plug 'ternjs/tern_for_vim'
" Plug 'bling/vim-airline'
Plug 'osyo-manga/vim-anzu'
" Plug 'Valloric/YouCompleteMe'
Plug 'SirVer/ultisnips'
Plug 'mhartington/vim-typings'
" Plug 'Shougo/unite.vim'
" Plug 'https://github.com/xolox/vim-easytags.git'
" Plug 'vim-scripts/YankRing.vim'
Plug 'vim-scripts/scratch.vim'
Plug 'craigemery/vim-autotag'
Plug 'majutsushi/tagbar'
Plug 'xolox/vim-misc'
" Plug 'https://github.com/xolox/vim-session.git'
Plug 'airblade/vim-gitgutter'
Plug 'Quramy/vim-js-pretty-template'
Plug 'Quramy/tsuquyomi'
Plug 'Shougo/vimproc.vim', {'do' : 'make'}
Plug 'HerringtonDarkholme/yats.vim'
Plug 'Olical/vim-enmasse'
" Plug 'https://github.com/vim-scripts/cscope.vim'
Plug 'vim-scripts/PreserveNoEOL'
Plug 'editorconfig/editorconfig-vim' "turn it back
Plug 'aperezdc/vim-template'
Plug 'Townk/vim-autoclose'
" Plug 'git://github.com/tpope/vim-cucumber.git'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-surround'
" Plug 'nathanaelkane/vim-indent-guides'
Plug 'flazz/vim-colorschemes'
Plug 'mileszs/ack.vim'
" Plug 'scrooloose/nerdtree'
" Plug 'jistr/vim-nerdtree-tabs'
" Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'othree/jsdoc-syntax.vim'
Plug 'heavenshell/vim-jsdoc'
Plug 'itspriddle/vim-jquery'
Plug 'othree/javascript-libraries-syntax.vim'
" Plug 'othree/jspc.vim'
" Plug 'severin-lemaignan/vim-minimap'
" Plug 'sheerun/vim-polyglot'

" Add plugins to &runtimepath
call plug#end()

" ================================================
" General
" ================================================
filetype plugin indent on
set shiftround " test
set showmatch " show maching parenthesis
set bufhidden=wipe
filetype on
set encoding=utf-8
set spelllang=en
set number
set ruler
set modelines=0
set history=1000
set undolevels=1000
set showcmd " show me what I'm typing
set laststatus=2
set wrap
set linebreak " preserve complete words when line break
set splitbelow " opens next horizontal window below current
set mouse=a
set mousemodel=popup
set ignorecase
set nrformats-=octal
set ttyfast
" set formatoptions=tcqrn1 " test
" autoread file changes
set autoread
set tabstop=2
set softtabstop=2 " test
set shiftwidth=2
set expandtab

" copy to system clipboard
if has("clipboard")
  set clipboard=unnamed

  if has("unnamedplus") " X11 clipboard support
    set clipboard+=unnamedplus
  endif
endif

" Hide Vim Intro
set shortmess+=I
" Hightlight Current Line
set cursorline
" Redraw ONLY When Need To
set lazyredraw
set magic " Enable Magic for Regular Expressions
set autoindent " auto indent
set smartindent " smart indent
set shell=sh
set gdefault " add 'g' to all replace options by default
set smartcase
set noswapfile
set nobackup
set backspace=indent,eol,start
set smarttab " insert tabs on the start of the line
" set foldlevel=1
" set foldmethod=marker
set nofoldenable " disable folding
set complete-=i " don't scan current file and includes
set hlsearch
set incsearch
set wildmenu
set wildmode=full " test
set guioptions-=r
set guioptions-=L
set guioptions-=e " for terminal type tabs in gui
set guicursor=n-v-c:blinkon0
set scrolloff=999
let mapleader = ","
set splitright
set pastetoggle=<F2> " Switch to paste mode when pasting bulk of text
set wildignore=*.bak,*.swp,*.pyc,*.class,*.o,*.out,*.obj,*.rbc,*.rbo
set wildignore+=**/node_modules/**,**/dist/**,**/compiled/**,**/docs/**,**/target/**
set wildignore+=**/.nyc_output/**
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
set wildignore+=**/vendor/gems/**,**/vendor/cache/**,**/.bundle/**,**/.sass-cache/**
set wildignore+=**/.git/**,**/.svn/**,**/.gem/**
set wildignore+=**/*~,**/._*
set wildignore+=**/project.vim,**/Session.vim
set noequalalways
set secure " not allow shell and write commands in autocmd
set exrc " allow project specific .vimrc files
set timeoutlen=1000 ttimeoutlen=0 " remove `O` and `o` Delay
set nopaste
set visualbell
set noerrorbells
set statusline=%<%f\ %y%h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P

set iskeyword-=!-~

if v:version >= 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif "

" Search down into subfolders
" Provides tab-completition for all file-related tasks
set path-=.
set path-=/usr/include
set path+=**

highlight OverLength ctermfg=white guibg=#592929
match OverLength /\%100v.\+/
set colorcolumn=100

if has('autocmd')
  augroup General_Autocmd
    autocmd!
    " Write variable s:std_in if arguments for VIM was passed
    autocmd StdinReadPre * let s:std_in=1
    autocmd BufNewFile,BufRead *.es6.js setf es6
    autocmd BufNewFile,BufRead *.tsx.js setf tsx
		autocmd BufNewFile,BufRead *.es6,*.tsx,*.jsx setl syntax=javascript
    autocmd BufNewFile,BufRead *.scss,*.sass setf css
    autocmd BufNewFile,BufRead *rc setf json
    autocmd BufReadPost * call SetupLinterStatusBar()
    autocmd BufEnter * call VimDiffSetupEnv()
    autocmd BufEnter * call SetTabNameToCurrentBuffer()
    autocmd BufEnter * call ApplyTemplate()
    autocmd FileType netrw call SetupNetrwEnv()
    autocmd CursorHold,CursorHoldI,InsertLeave * call HighlightWordUnderCursor()
    autocmd InsertEnter * match none
    autocmd TabNew * call SetupTabEnv()
    autocmd VimEnter * call SetupTabEnv()
    autocmd VimEnter * call StartVimInNetrwModeIfNoFilePassed()
    autocmd VimEnter * call RestoreProject()
    autocmd VimEnter * call RestoreSession()
    autocmd VimEnter * call DevelSetupEnv()
    autocmd VimLeave * call SaveSession()
    autocmd BufWinEnter * call OnEnterWin()
    autocmd BufWinLeave * call OnCloseWin()
    autocmd QuickFixCmdPost *grep* cwindow | let t:quickfix_is_open = 1

    " autocmd BufWinEnter * echom 'BufWinEnter'
    " autocmd BufEnter * echom 'BufEnter'
    " autocmd BufRead * echom 'BufRead'
    " autocmd BufNewFile * echom 'BufNewFile'
  augroup END

  if has('omnifunc')
    augroup Omnifuncs
      autocmd!
      autocmd Filetype * if &omnifunc == "" | set omnifunc=syntaxcomplete#Complete | endif
    augroup END
  endif
endif

function! DisableLinters() abort
  exe ':ALEDisable'
  echo 'Linters disabled.'
endfunction


function! EnableLinters() abort
  exe ':ALEEnable'
  echo 'Linters enabled.'
endfunction

command! DisableLinters :call DisableLinters()
command! EnableLinters :call EnableLinters()

function! DevelSetupEnv() abort
  let g:UltiSnipsSnippetDirectories = [$HOME . '/.vim/ultisnips']
  if exists('g:project_type')
    let l:snippets_basepath = $HOME . '/.vim/ultisnips/'
    let l:snippets_path = l:snippets_basepath . g:project_type

    if isdirectory(l:snippets_path)
      let g:UltiSnipsSnippetDirectories = [l:snippets_path] + g:UltiSnipsSnippetDirectories
    else
      echom "Snippets folder '" . l:snippets_path . "' doesn't exists!"
    endif
  endif
endfunction

function! StartVimInNetrwModeIfNoFilePassed() abort
  if argc() == 0 && !exists('s:std_in') && !&diff && !SessionFileExists()
    exe 'windo :Explore'
  endif
endfunction

function! IsBufferDevel() abort
  return &ft == 'javascript' || &ft == 'javascript.jsx' || &ft == 'json' || &ft == 'java' || &ft == 'ruby' || &ft == 'php' || &ft == 'css' || &ft == 'html' || &ft == 'conf' || &ft == 'vim' || &ft == 'xml'
endfunction

" Highlight word under the cursor.
function! HighlightWordUnderCursor() abort
	if IsBufferDevel() && mode() == 'n'
    if getline(".")[col(".")-1] !~# '[[:punct:][:blank:]]' && !empty(expand('<cword>'))
      exe 'match' 'Search' '/\v' . expand('<cword>') . '/'
    else
      match none
    endif
	endif
endfunction

function! McopyFilePathToClipboard() abort
  redir @*
  echo expand('%:p:h')
  redir END
endfunction

" Proper comments
noremap <c-_><c-_> :Commentary<cr>

nnoremap <leader>cf :call McopyFilePathToClipboard()<cr>

" Close all tabs but the current
nnoremap <c-t>o :call CloseAllTabsButCurrent()<cr>

function! CloseAllTabsButCurrent() abort
  silent exe ":tabo"
  echo "All other tabs are closed."
endfunction

" Show all the marks
command! Ma :exe ":marks"

" Delete strings without poluting last yank buffer
" nnoremap <leader>y "_y
" nnoremap <leader>p "_p
" nnoremap <leader>d "_d
" nnoremap <leader>x "_x
" nnoremap <leader>c "_c
" nnoremap <leader>dw "_dw
" nnoremap <leader>xw "_xw
" nnoremap <leader>cw "_cw
" nnoremap <leader>de "_de
" nnoremap <leader>xe "_xe
" nnoremap <leader>ce "_ce

" should fix some problems with searching regex - test
" noremap / /\v
" vnoremap / /\v

" search for visualy selected text
vnoremap // y/<c-r>"<cr>"

" Reload vim ~/.vimrc
command! ReloadConfig so ~/.vimrc | echom 'Config reloaded'

" Copy word under the cursor to clipboard
nnoremap <leader>y :call CopyCwordToClipboard()<cr>

function! CopyCwordToClipboard() abort
  normal viwy
  echo "Text '" . expand("<cword>") . "' has been copied to clipboard."
endfunction

" Search for word under cursor.
nnoremap <C-h> :help <cword><cr>

" Reselects just pasted text
nnoremap <leader>v V`]`

let g:closetag_filenames = "*.html,*.xhtml,*.phtml"

let &gp='grep -n -R $* /dev/null'

" ================================================
" Copy & paste
" ================================================

" nnoremap <silent> <F3> :YRShow<cr>
" inoremap <silent> <F3> <ESC>:YRShow<cr>

" ================================================
" Tmux Support
" ================================================

" Write all buffers before navigating from Vim to tmux pane
let g:tmux_navigator_save_on_switch = 2

" ================================================
" VImux - Tmux plugin
" ================================================

" Inspect runner pane
nnoremap <leader>vi :VimuxInspectRunner<cr>

" Zoom the tmux runner pane
nnoremap <leader>vz :VimuxZoomRunner<cr>

" Disable tmux navigator when zooming the Vim pane
" let g:tmux_navigator_disable_when_zoomed = 1

" Change root directory to local file dir
nnoremap <silent> <leader>cd :cd %:p:h<cr>

" ================================================
" Linting and formatting
" ================================================

if v:version >= 800
  let g:ale_fix_on_save = 1
  let g:ale_lint_on_enter = 1
  let g:ale_lint_on_filetype_changed = 1
  let g:ale_pattern_options_enabled = 1
  let g:linterIgnoredSuffixes = ['\.min\.js$', '\.min\.css$', '\.vim$']
  let g:ale_pattern_options = {}

  for item in g:linterIgnoredSuffixes
    let g:ale_pattern_options[item] = {'ale_linters': [], 'ale_fixers': []}
  endfor

  " let g:ale_pattern_options = {
  "   \ '\.min\.js$': {'ale_linters': [], 'ale_fixers': []},
  "   \ '\.min\.css$': {'ale_linters': [], 'ale_fixers': []},
  "   \ '\.vim$'
  "   \}

  " If you configure g:ale_pattern_options outside of vimrc, you need this.
endif

function! ThisFileLintingSupported() abort
  if v:version < 800
    return 0
  endif

  let l:currentFileName = expand('%:t')

  if exists('g:linterIgnoredSuffixes')
    for item in g:linterIgnoredSuffixes
      if l:currentFileName =~ item
        return 0
      endif
    endfor
  endif

  return 1
endfunction

function! SetupLinters() abort
  if g:loaded_ale && v:version >= 800
    let g:ale_linters = {}
    let g:ale_fixers = {}
    let g:ale_linter_aliases = {}

    call SetupLinterJavascript()
  else
    echom 'Linters could not be configured.'
  endif
endfunction

function! SetupLinterJavascript() abort
endfunction

function! SetupLinterStatusBar() abort
  if exists('g:loaded_ale') && ThisFileLintingSupported()
    function! LinterStatusbar() abort
      let l:message = '[Linter: '

      if g:ale_enabled
        if exists('g:ale_linters[&ft]')
          let l:count = ale#statusline#Count(bufnr(''))
          let l:errors = 0
          let l:warnings = 0
          let l:styleError = 0
          let l:totalErrors = 0

          if type(l:count) == type({})
            let l:errors = l:count.error
            let l:warnings = l:count.warning
            let l:styleError = l:count.style_error
            let l:totalErrors = l:count.total

          elseif type(l:count) == type([])
            let [ l:errors, l:warnings ] = l:count
            let l:totalErrors = l:errors
          endif

          let l:totalIssues = l:errors + l:warnings + l:styleError

          if l:totalIssues
            let l:all_errors = l:errors + l:styleError
            let l:all_non_errors = l:totalErrors - l:all_errors
            let l:message .= printf('%dW %dE', all_non_errors, all_errors)
          else
            let l:message .= 'ok'
          endif
        else
          return '[No Linter]'
        endif
      else
        let l:message .= 'disabled'
      endif

      return l:message . ']'
    endfunction

    setlocal statusline=%<%f\ %y%h%m%r%{fugitive#statusline()}\ %{LinterStatusbar()}%=%-14.(%l,%c%V%)\ %P
  endif
endfunction

" ================================================
" Emmet
" ================================================

let g:user_emmet_install_global = 0
let g:user_emmet_leader_key='<leader>z'
let g:user_emmet_mode='a'

" ================================================
" Windows & splits manipulaton
" ================================================

" easier cycling and delete buffers in current window
nnoremap gp :bprevious<cr>
nnoremap gb :bnext<cr>
nnoremap <silent> <LEADER>gd :bd<cr>

" Toggle horizontal/vertical split
function! ToggleWindowHorizontalVerticalSplit() abort
  if !exists('t:splitType')
    let t:splitType = 'vertical'
  endif

  if t:splitType == 'vertical' " is vertical switch to horizontal
    windo wincmd K
    let t:splitType = 'horizontal'

  else " is horizontal switch to vertical
    windo wincmd H
    let t:splitType = 'vertical'
  endif
endfunction

nnoremap <silent> <leader>wt :call ToggleWindowHorizontalVerticalSplit()<cr>

function! DeleteHiddenBuffers() abort
  let tpbl=[]
  call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
  for buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val)==-1')
    silent! execute 'bwipeout!' buf
  endfor
  let t:quickfix_is_open = 0
  echom "Hidden buffers wiped out!"
endfunction

nnoremap <silent> <leader>bw :call DeleteHiddenBuffers()<cr>

function! AlignBuffer() abort
  let l:isPHP = 0

  if &ft ==# 'php'
    let l:isPHP = 1
    setl ft=html
  endif

  exe "normal! mm"
  exe "normal! gg"
  exe "normal! VG"
  exe "normal! ="
  exe "normal! 'm"

  if l:isPHP
    setl ft=php
  endif
endfunction

nnoremap <leader>w= :call AlignBuffer()<cr>

" Count occourences of selected text.
nnoremap <leader>* *<C-O>:%s///gn<cr>

" Remove empty lines
command! MremoveEmptyLines g/^\s*$/d

" ================================================
" QuickFix
" ================================================

nnoremap <silent> <leader>q :call QuickfixToggle()<cr>
nnoremap <silent> <leader>e :call LocationListToggle()<cr>

function! OnEnterWin() abort
  let b:location_list_is_open = 0

  " if &ft == 'qf'
  "   let t:quickfix_is_open = 1
  " endif
endfunction

function! OnCloseWin() abort
  if &ft == 'qf'
    let t:quickfix_is_open = 0
  endif
endfunction

function! SetupTabEnv() abort
  let t:quickfix_is_open = 0
endfunction

function! QuickfixToggle() abort
  if t:quickfix_is_open
    cclose
    let t:quickfix_is_open = 0
  else
    copen
    let t:quickfix_is_open = 1
  endif
endfunction

function! LocationListToggle() abort
  if exists('b:location_list_is_open') && b:location_list_is_open
    lclose
    let b:location_list_is_open = 0
  else
    lopen
    let b:location_list_is_open = 1
  endif
endfunction

function! SetTabNameToCurrentBuffer() abort
  let l:currentBufferName = expand('%:t')
  if !empty(l:currentBufferName)
    exe ':TabooRename ' . l:currentBufferName
  endif
endfunction

" ================================================
" Diff
" ================================================

set diffopt+=iwhite

function! VimDiffSetupEnv() abort
  if &diff
    nnoremap <leader>1 :diffget LOCAL<cr>
    nnoremap <leader>2 :diffget BASE<cr>
    nnoremap <leader>3 :diffget REMOTE<cr>
  endif
endfunction

" ================================================
" Snippets
" ================================================

let g:UltiSnipsUsePythonVersion=2
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<C-j>"
let g:UltiSnipsJumpBackwardTrigger="<C-k>"
let g:UltiSnipsListSnippets='<C-tab>'

" ================================================
" General Mapings & Ab
" ================================================

noremap <Up> gk
noremap <Down> gj
ounmap <Up>
ounmap <Down>

" clear search highlight
noremap <silent> ,/ :nohlsearch<cr>

" execute commands with ;
nnoremap ; :

" allows entering sudo write mode
cmap w!! w !sudo tee % >/dev/null

" search for visualy selected text
vnoremap * y/<C-R>"<cr>"

" close all buffers except current one
nnoremap <silent> <leader>bd :%bd\|e# <cr>

" Goto local definition and add mark to starting line
nnoremap gd mm gd
" nnoremap gg mm gg
" nnoremap G mm G

" Quick Toggle Background BEtween Dark & Light
nnoremap <leader>Tn :let &background=(&background=="dark"?"light":"dark")<cr>

" ================================================
" Look & Feel
" ================================================

colorscheme mustang
set background=dark

" ================================================
" VIM gui settings
" ================================================

 " turn sytax highlight when terminal has colors
if has('gui_running') || &t_Co >= 2
  syntax on
endif

" start in full screen mode when run gui
if has('gui_running')
  set lines=9999 columns=9999
endif

" ================================================
" EditorConfig
" ================================================

let g:EditorConfig_exclude_patterns = ['fugitive://.*', 'scp://.*']
let g:EditorConfig_exec_path = '/usr/local/bin/editorconfig'
let g:EditorConfig_core_mode = 'external_command'

" ================================================
" Tagbar
" ================================================

noremap <leader>b :TagbarToggle<cr>

" ================================================
" Git - gutter
" ================================================

set updatetime=250
command! -nargs=? MGitBase call SetGitGutterBase(<f-args>)

function! SetGitGutterBase(...) abort
  let g:gitgutter_diff_base = a:0 == 0 ? '' : a:1
  echo 'g:gitgutter_diff_base: ' . g:gitgutter_diff_base
  GitGutter
endfunction

" ================================================
" Session
" ================================================

set ssop-=options	" Don't store local and global options
set ssop-=globals
set ssop-=folds " Don't store folds
set ssop-=blank " Don't save empty windows
set ssop+=resize " Save window views
set ssop+=winpos
set ssop+=help
set ssop+=localoptions

function! SessionFileExists() abort
  return filereadable(getcwd() . '/Session.vim')
endfunction

function! ProjectFileExists() abort
  return filereadable(GetProjectFilename())
endfunction

function! GetProjectFilename() abort
  return getcwd() . '/project.vim'
endfunction

function! GetSessionFilename() abort
  return getcwd() . '/Session.vim'
endfunction

function! RestoreProject() abort
  if exists('s:std_in') || &diff
    return
  endif

	if ProjectFileExists()
    echom 'Restoring project...'
    exe 'so ' . GetProjectFilename()
	endif
endfunction

" Restore VIM session if ./Session.vim file exists.
function! RestoreSession() abort
  if exists('s:std_in') || exists("g:nosession") || &diff
    return
  endif

  if SessionFileExists()
    echom 'Restoring session...'
    silent! exe 'so ' . GetSessionFilename
  endif
endfunction

function! SaveSession() abort
  let l:projectFileExists = ProjectFileExists()

  if l:projectFileExists
    " Save netrw windows state
    bufdo setl bl
    exe 'mksession!'
    call SaveTabooTabNames()
  endif
endfunction

function! SaveTabooTabNames() abort
  if exists(':TabooRename')
    let l:sessionFilename = GetSessionFilename()
    silent exe "!echo 'if exists(\":TabooRename\")' >> " . l:sessionFilename
    silent exe "!echo 'let s:tabNames = {}' >> " . l:sessionFilename
    tabdo call SaveTabooTabName()

    silent exe "!echo 'tabdo if has_key(s:tabNames, tabpagenr()) | exe \"TabooRename \" . s:tabNames[tabpagenr()] | endif ' >> " . l:sessionFilename
    silent exe "!echo 'unlet s:tabNames' >> " . l:sessionFilename
    silent exe "!echo 'exe \"tabfirst\"' >> " . l:sessionFilename
    silent exe "!echo 'endif' >> " . l:sessionFilename
  endif
endfunction

function! SaveTabooTabName() abort
  let l:tabnr = tabpagenr()
  let l:tabooTabName = gettabvar(l:tabnr, 'taboo_tab_name')
  if !empty(l:tabooTabName)
    silent exe "!echo 'let s:tabNames[" . l:tabnr . "] = \"" . l:tabooTabName . "\"' >> " . GetSessionFilename()
  endif
endfunction

" ================================================
" Projects
" ================================================

let s:projectsFolder = '~/.vim/projects'

function! InitReactProject() abort
  call CopyProjectFileIntoCwd(expand(s:projectsFolder . '/react.vim'), 'React')
endfunction

function! InitReactNativeProject() abort
  call CopyProjectFileIntoCwd(expand(s:projectsFolder . '/react-native.vim'), 'React Native')
endfunction

function! InitNodeProject() abort
  call CopyProjectFileIntoCwd(expand(s:projectsFolder . '/node.vim'), 'node')
endfunction

function! CopyProjectFileIntoCwd(configPath, type) abort
  if filereadable(a:configPath)
    exe '!cp ' . a:configPath . ' project.vim'
    echo a:type . ' project initiated.'
  else
    echoe "Project config file '" . a:configPath . "' doesn't exists!"
  endif

  call DevelSetupEnv()
endfunction

command! InitNodeProject :call InitNodeProject()
command! InitReactProject :call InitReactProject()
command! InitReactNativeProject :call InitReactNativeProject()

" ================================================
" Fuzz Search - find any phrase in all files
" ================================================

nnoremap <leader>f :call FuzzSearchCursor()<cr>
vnoremap <leader>f :call FuzzSearchVisual()<cr>

" Call Ack as Ack! (not open preview automaticaly)
" cnoreabbrev Ack Ack!

function! FuzzSearchCursor() abort
  let l:phrase = input('What pattern? ', expand('<cword>'))
  call FuzzSearchForPhrase(l:phrase)
endfunction

function! FuzzSearchForPhrase(phrase) abort
  if empty(a:phrase)
    return
  endif

  let l:command = ':grep!'

  if exists(':Ack') && executable('ack')
    let l:command =  ':Ack!'
  endif

  silent exe l:command  . " '" . a:phrase . "' ."
  " let t:quickfix_is_open = 1
endfunction

function! FuzzSearchVisual() abort
  let l:phrase = getline("'<")[getpos("'<")[2]-1:getpos("'>")[2]-1]
  call FuzzSearchForPhrase(l:phrase)
endfunction

function! SearchAndReplace(phrase) abort
  let l:phrase = input('What text to replace? ', a:phrase)
  if empty(l:phrase)
    return
  endif

  let l:replacement = input('What text for replacement? ', l:phrase)
  if empty(l:replacement)
    return
  endif

  call FuzzSearchForPhrase(l:phrase)

  set hidden
  set autosave
  cfdo exe "%s/" . l:phrase . "/" . l:replacement . "/"
  set nohidden
  set noautosave
endfunction

command! SearchAndReplace :call SearchAndReplace(expand("<cword>"))

nnoremap <leader>d :SearchAndReplace

" ================================================
" Tags
" ================================================

let g:autotagTagsFile="tags"

if has('path_extra')
  setg tags-=./tags
endif

function! GenerateCtags() abort
  let l:command = "ctags -R ."
  call xolox#misc#os#exec({'command': l:command, 'check': 0, 'async': v:version >= 800 })
endfunction

command! Ctags call GenerateCtags()

" Open tag definition in new tab
" nnoremap <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>

" Open tag definition in vertical split
nnoremap <C-w><C-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" ================================================
" CtrlP
" ================================================

let g:ctrlp_working_path_mode = 0
let g:ctrlp_root_markers = ['package.json']
let g:ctrlp_regexp = 1
let g:ctrlp_by_filename = 1
let g:ctrlp_switch_buffer = 'e'
let g:ctrlp_reuse_window = 'netrw\|help\|quickfix'
let g:ctrlp_tabpage_position = 'ac'
let g:ctrlp_use_caching = 1
let g:ctrlp_max_files = 50
let g:ctrlp_open_new_file = 'v'
let g:ctrlp_open_multiple_files = 'v'
let g:ctrlp_follow_symlinks = 1
let g:ctrlp_types = ['fil', 'mru']
let g:ctrlp_open_single_match = ['buffer tags', 'buffer']
let g:ctrlp_extensions = ['buffertag', 'tag', 'mixed', 'bookmarkdir']
let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:10'
let g:ctrlp_map = '<leader>p'

" nnoremap <leader>p :CtrlP<cr>
nnoremap <leader>t :CtrlPTag<cr>
nnoremap <leader>r :CtrlPMRU<cr>

" ================================================
" Tabularize
" ================================================

if exists(":Tabularize")
  noremap <leader>a= :Tabularize /=<cr>
  noremap <leader>a: :Tabularize /:\zs<cr>

  " tabularize on every | char
  " inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<cr>a
  " function! s:align()
  "   let p = '^\s*|\s.*\s|\s*$'
  "   if getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
  "     let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
  "     let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
  "     Tabularize/|/l1
  "     normal! 0
  "     call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  "   endif
  " endfunction
endif

" ================================================
" Templating
" ================================================

let g:username = $USER_NAME
let g:email = $EMAIL
let g:license = 'BSD 2-Clause' " 'Proprietary'
let s:client = $BIZ_CLIENT
let g:templates_no_autocmd = 1

if !empty(s:client)
  let g:templates_directory = '~/.vim/templates/' . s:client
endif

function! ApplyTemplate() abort
  if &ft ==? 'netrw'
    return
  endif

	if !empty(s:client)
    let l:content = getline(0,line("$"))
    let l:result = 0
    for l:temp in l:content
      if strlen(l:temp) > 0
        let l:result = 1
        break
      endif
    endfor
    if l:result == 0
      let l:extension = expand("%:c")
      exe 'Template .' . l:extension
    endif
  endif
endfunction

function! ExecuteMacroOverVisualRange() abort
  echo "@".getcmdline()
  execute ":'<,'>normal @".nr2char(getchar())
endfunction

xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<cr>

" ================================================
" Netrw
" ================================================

function! SetupNetrwEnv() abort
  setl hidden
  setl bufhidden=delete
  setl buftype=nofile
  nnoremap <buffer> gn :Ntree<cr>
endfunction

let g:netrw_fastbrowse = 0
let g:netrw_use_errorwindow = 0 " show netrw messages as echoerr
let g:netrw_localmkdir = 'mkdir -p '
let g:netrw_banner = 0 " disable banner
let g:netrw_browse_split = 0 " open in new horizontal split
let g:netrw_altv = 1 " open splits on the right
let g:netrw_liststyle = 3 " tree view
let g:netrw_preview = 1
let g:netrw_list_hide = netrw_gitignore#Hide()
let g:netrw_list_hide += ',\(^\|\s\s\)\zs\.\S\+'
let g:netrw_list_hide += ',\.git'
let g:netrw_list_hide += ',.DS_Store'
let g:netrw_list_hide += ',node_modules'
let g:netrw_list_hide += ',\.gem,\.bundle'
let g:netrw_winsize = 75
let g:netrw_wiw = 25
let g:netrw_localrmdir = 'rm -r' " Remove local non-empty directories

nnoremap <leader>3 :exe "Vexplore " expand('%:p:h') <cr>
nnoremap <leader>m :exe "vs " expand('%:p:h') <cr>
nnoremap <leader>k :vs .<cr>
nnoremap <leader>l :e .<cr>
nnoremap <leader>. :Explore<cr>
